import { useEffect, useRef, useState, useId } from "react";

const useDarkMode = () => {
  const [isDark, setIsDark] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    setIsDark(mediaQuery.matches);

    const handler = (e) => setIsDark(e.matches);
    mediaQuery.addEventListener("change", handler);
    return () => mediaQuery.removeEventListener("change", handler);
  }, []);

  return isDark;
};

// ======================================================================
// FIXED + SAFE VERSION OF GlassSurface
// ======================================================================
const GlassSurface = ({
  children,
  width = 200,
  height = 80,
  borderRadius = 20,
  borderWidth = 0.07,
  brightness = 50,
  opacity = 0.93,
  blur = 11,
  displace = 0,
  backgroundOpacity = 0,
  saturation = 1,
  distortionScale = -180,
  redOffset = 0,
  greenOffset = 10,
  blueOffset = 20,
  xChannel = "R",
  yChannel = "G",
  mixBlendMode = "difference",
  className = "",
  style = {},
}) => {
  const uniqueId = useId().replace(/:/g, "-");
  const filterId = `glass-filter-${uniqueId}`;
  const redGradId = `red-grad-${uniqueId}`;
  const blueGradId = `blue-grad-${uniqueId}`;

  const containerRef = useRef(null);
  const feImageRef = useRef(null);
  const redChannelRef = useRef(null);
  const greenChannelRef = useRef(null);
  const blueChannelRef = useRef(null);
  const gaussianBlurRef = useRef(null);

  const isDarkMode = useDarkMode();

  // ======================================================================
  // SAFE FEATURE DETECTION (won’t crash React / SSR / Safari)
  // ======================================================================
  const supportsBackdropFilter = () => {
    if (typeof window === "undefined" || typeof CSS === "undefined") return false;
    try {
      return CSS.supports("backdrop-filter", "blur(10px)");
    } catch {
      return false;
    }
  };

  const supportsSVGFilters = () => {
    if (typeof window === "undefined" || typeof navigator === "undefined") return false;

    try {
      const ua = navigator.userAgent;
      const isWebkit = /Safari/.test(ua) && !/Chrome/.test(ua);
      const isFirefox = /Firefox/.test(ua);
      if (isWebkit || isFirefox) return false;

      const div = document.createElement("div");
      div.style.backdropFilter = `url(#${filterId})`;
      return div.style.backdropFilter !== "";
    } catch {
      return false;
    }
  };

  // ======================================================================
  // DISPLACEMENT MAP GENERATION
  // ======================================================================
  const generateDisplacementMap = () => {
    const rect = containerRef.current?.getBoundingClientRect();
    const actualWidth = rect?.width || 400;
    const actualHeight = rect?.height || 200;
    const edgeSize = Math.min(actualWidth, actualHeight) * (borderWidth * 0.5);

    const svgContent = `
      <svg viewBox="0 0 ${actualWidth} ${actualHeight}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="${redGradId}" x1="100%" y1="0%" x2="0%" y2="0%">
            <stop offset="0%" stop-color="#0000"/>
            <stop offset="100%" stop-color="red"/>
          </linearGradient>

          <linearGradient id="${blueGradId}" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#0000"/>
            <stop offset="100%" stop-color="blue"/>
          </linearGradient>
        </defs>

        <rect width="${actualWidth}" height="${actualHeight}" fill="black" />
        <rect width="${actualWidth}" height="${actualHeight}" rx="${borderRadius}" fill="url(#${redGradId})" />
        <rect width="${actualWidth}" height="${actualHeight}" rx="${borderRadius}" fill="url(#${blueGradId})" style="mix-blend-mode:${mixBlendMode}"/>
        <rect x="${edgeSize}" y="${edgeSize}"
              width="${actualWidth - edgeSize * 2}"
              height="${actualHeight - edgeSize * 2}"
              rx="${borderRadius}"
              fill="hsl(0 0% ${brightness}% / ${opacity})"
              style="filter:blur(${blur}px)"
        />
      </svg>
    `;

    return `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
  };

  const updateDisplacementMap = () => {
    if (feImageRef.current) {
      feImageRef.current.setAttribute("href", generateDisplacementMap());
    }
  };

  // ======================================================================
  // UPDATE FILTERS ON PROPS CHANGE
  // ======================================================================
  useEffect(() => {
    updateDisplacementMap();

    [
      { ref: redChannelRef, offset: redOffset },
      { ref: greenChannelRef, offset: greenOffset },
      { ref: blueChannelRef, offset: blueOffset },
    ].forEach(({ ref, offset }) => {
      if (ref.current) {
        ref.current.setAttribute("scale", (distortionScale + offset).toString());
        ref.current.setAttribute("xChannelSelector", xChannel);
        ref.current.setAttribute("yChannelSelector", yChannel);
      }
    });

    if (gaussianBlurRef.current) {
      gaussianBlurRef.current.setAttribute("stdDeviation", displace.toString());
    }
  }, [
    width,
    height,
    borderRadius,
    borderWidth,
    brightness,
    opacity,
    blur,
    displace,
    distortionScale,
    redOffset,
    greenOffset,
    blueOffset,
    xChannel,
    yChannel,
    mixBlendMode,
  ]);

  // ======================================================================
  // RESIZE OBSERVER (cleaned, no duplicates)
  // ======================================================================
  useEffect(() => {
    if (!containerRef.current) return;

    const ro = new ResizeObserver(() => {
      setTimeout(updateDisplacementMap, 0);
    });

    ro.observe(containerRef.current);
    return () => ro.disconnect();
  }, []);

  useEffect(() => {
    setTimeout(updateDisplacementMap, 0);
  }, [width, height]);

  // ======================================================================
  // FINAL STYLE LOGIC (unchanged behavior)
  // ======================================================================
  const getContainerStyles = () => {
    const baseStyles = {
      ...style,
      width: typeof width === "number" ? `${width}px` : width,
      height: typeof height === "number" ? `${height}px` : height,
      borderRadius: `${borderRadius}px`,
      "--glass-frost": backgroundOpacity,
      "--glass-saturation": saturation,
    };

    const svgOK = supportsSVGFilters();
    const blurOK = supportsBackdropFilter();

    if (svgOK) {
      return {
        ...baseStyles,
        background: isDarkMode
          ? `hsl(0 0% 0% / ${backgroundOpacity})`
          : `hsl(0 0% 100% / ${backgroundOpacity})`,
        backdropFilter: `url(#${filterId}) saturate(${saturation})`,
        boxShadow: isDarkMode
          ? `0 0 2px 1px rgba(255,255,255,0.35) inset,
             0 0 10px 4px rgba(255,255,255,0.15) inset`
          : `0 0 2px 1px rgba(0,0,0,0.15) inset,
             0 0 10px 4px rgba(0,0,0,0.05) inset`,
      };
    }

    // fallback modes… unchanged...
    if (isDarkMode) {
      if (!blurOK) {
        return {
          ...baseStyles,
          background: "rgba(0,0,0,0.4)",
          border: "1px solid rgba(255,255,255,0.2)",
        };
      }
      return {
        ...baseStyles,
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(12px) saturate(1.8)",
        border: "1px solid rgba(255,255,255,0.2)",
      };
    } else {
      if (!blurOK) {
        return {
          ...baseStyles,
          background: "rgba(255,255,255,0.4)",
          border: "1px solid rgba(255,255,255,0.3)",
        };
      }
      return {
        ...baseStyles,
        background: "rgba(255,255,255,0.25)",
        backdropFilter: "blur(12px) saturate(1.8)",
        border: "1px solid rgba(255,255,255,0.3)",
      };
    }
  };

  // ======================================================================
  // RENDER
  // ======================================================================
  return (
    <div
      ref={containerRef}
      className={`relative flex items-center justify-center overflow-hidden transition-opacity duration-260ms ease-out ${className}`}
      style={getContainerStyles()}
    >
      <svg className="w-full h-full pointer-events-none absolute inset-0 opacity-0 -z-10">
        <defs>
          <filter id={filterId} colorInterpolationFilters="sRGB" x="0%" y="0%" width="100%" height="100%">
            <feImage ref={feImageRef} width="100%" height="100%" preserveAspectRatio="none" result="map" />

            <feDisplacementMap ref={redChannelRef} in="SourceGraphic" in2="map" result="dispRed" />
            <feColorMatrix
              in="dispRed"
              type="matrix"
              values="1 0 0 0 0
                      0 0 0 0 0
                      0 0 0 0 0
                      0 0 0 1 0"
              result="red"
            />

            <feDisplacementMap ref={greenChannelRef} in="SourceGraphic" in2="map" result="dispGreen" />
            <feColorMatrix
              in="dispGreen"
              type="matrix"
              values="0 0 0 0 0
                      0 1 0 0 0
                      0 0 0 0 0
                      0 0 0 1 0"
              result="green"
            />

            <feDisplacementMap ref={blueChannelRef} in="SourceGraphic" in2="map" result="dispBlue" />
            <feColorMatrix
              in="dispBlue"
              type="matrix"
              values="0 0 0 0 0
                      0 0 0 0 0
                      0 0 1 0 0
                      0 0 0 1 0"
              result="blue"
            />

            <feBlend in="red" in2="green" mode="screen" result="rg" />
            <feBlend in="rg" in2="blue" mode="screen" result="output" />

            <feGaussianBlur ref={gaussianBlurRef} in="output" stdDeviation="0.7" />
          </filter>
        </defs>
      </svg>

      <div className="w-full h-full flex items-center justify-center p-2 rounded-[inherit] relative z-10">
        {children}
      </div>
    </div>
  );
};

export default GlassSurface;
